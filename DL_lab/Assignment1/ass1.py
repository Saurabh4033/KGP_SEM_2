# -*- coding: utf-8 -*-
"""MP_Neuron.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PcawGQKuTJ5YGLAtgqibxdn9KPmlgNCU

#Saurabh Jaiswal
#24AI60R46

# Assignment 1: The MC Neuron Model (20 marks)
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.inspection import DecisionBoundaryDisplay

# MP Neuron Model with Inhibitory Input Support
print("MP Neuron code")

def mp_neuron(inputs, threshold, inhibitory_indices=[],roll=46):
    # Compute excitatory sum
    excitatory_sum = sum(inputs[i] for i in range(len(inputs)) if i not in inhibitory_indices)

    # Check for inhibitory inputs and their influence
    for idx in inhibitory_indices:
        if inputs[idx] >= 0.5:
            return 0  # Immediate deactivation due to inhibitory input

    # Activation based on threshold
    return int(excitatory_sum >= threshold)

print("MP Neuron code end")

"""## Question 1 [3 marks]"""

print("And gate code.")
def and_gate(x1, x2):
  return mp_neuron([x1, x2], 2)

print("NOT gate code.")
def not_gate(x1):
  return mp_neuron(np.array([x1]), -np.inf, inhibitory_indices=[0])

print("NAND gate code.")
def nand_gate(x1, x2):
  return not_gate(and_gate(x1, x2))

#NAND
print("NAND gate operation.")
def Nand():
  # Inputs and ground truth for NAND gate
  inputs_NAND = [[0, 0], [0, 1], [1, 0], [1, 1]]
  ground_truth_NAND = [1, 1, 1, 0]

  # Placeholder for NAND gate outputs
  outputs_NAND = []

  # Generate outputs using the NAND gate function
  for inputs in inputs_NAND:
      outputs_NAND.append(nand_gate(inputs[0], inputs[1]))

  # Display results
  print("NAND Gate")
  print(f"Input Combinations: {inputs_NAND}")
  print(f"Expected Outputs: {ground_truth_NAND}")
  print(f"Computed Outputs: {outputs_NAND}")
print("NAND gate operation Complete.")

# NAND
print("Calling Nand gate operation.")
Nand()

"""## Question 2 [3 marks]"""

def nor_gate(x1, x2):
  return mp_neuron([x1, x2], -10, [0, 1])

# def nor_gate(x1, x2):
#   return not_gate(or_gate(x1, x2))

# NOR
print("NOR gate operation.")
def test_nor_gate():
    # Define inputs and ground truth
    inputs_NOR = [[0, 0], [0, 1], [1, 0], [1, 1]]
    ground_truth_NOR = [1, 0, 0, 0]

    # Compute outputs using the NOR gate function
    outputs_NOR = [nor_gate(inputs[0], inputs[1]) for inputs in inputs_NOR]

    # Display the results
    print("Input Combinations:", inputs_NOR)
    print("Expected Outputs:", ground_truth_NOR)
    print("Computed Outputs:", outputs_NOR)
print("NOR gate operation Complete.")

print("Calling Nor gate operation.")
test_nor_gate()
print("Nor gate end.")

"""## Question 3 [3 marks]"""

print("XOR gate code.")
def xor_gate(x1, x2):
  #x1.x2bar
  a=mp_neuron([x1, x2], 1, [1])
  b=mp_neuron([x1, x2], 1, [0])
  return mp_neuron([a, b], 1)
  #x2.x1bar

# Complete XOR Gate Operation
print("XOR Gate")

def test_xor_gate():
    # Define inputs and ground truth
    inputs_XOR = [[0, 0], [0, 1], [1, 0], [1, 1]]
    ground_truth_XOR = [0, 1, 1, 0]

    # Compute outputs using the XOR gate function
    outputs_XOR = [xor_gate(inputs[0], inputs[1]) for inputs in inputs_XOR]

    # Display the results
    print("Input Combinations:", inputs_XOR)
    print("Expected Outputs:", ground_truth_XOR)
    print("Computed Outputs:", outputs_XOR)
print("XOR Gate complete")

print("Calling XOR gate operation.")
test_xor_gate()
print("XOR gate end.")

"""## Question 4 [6 marks]"""

# NAND Decision Boundary
print("NAND Decision Boundary")

def nand_decision_boundary():
    # Define inputs and corresponding outputs for the NAND gate
    inputs_NAND = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
    outputs_NAND = np.array([nand_gate(input_pair[0], input_pair[1]) for input_pair in inputs_NAND])

    # Create a grid of points for the decision boundary
    grid_x, grid_y = np.meshgrid(np.linspace(-0.5, 1.5, 100),np.linspace(-0.5, 1.5, 100))
    grid_points = np.c_[grid_x.ravel(), grid_y.ravel()]

    # Evaluate the NAND gate on the grid points
    boundary_values = np.array([nand_gate(point[0], point[1]) for point in grid_points])
    boundary_values = boundary_values.reshape(grid_x.shape)

    # Plot the decision boundary using DecisionBoundaryDisplay
    disp = DecisionBoundaryDisplay(xx0=grid_x, xx1=grid_y, response=boundary_values)
    disp.plot(cmap=plt.cm.Paired, alpha=0.5)

    # Scatter plot for the original inputs and outputs
    plt.scatter(
        inputs_NAND[:, 0],
        inputs_NAND[:, 1],
        c=outputs_NAND,
        edgecolor="k",
        cmap=plt.cm.Paired,
        label="Inputs"
    )

    # Add plot labels and title
    plt.title("NAND Gate Decision Boundary")
    plt.xlabel("Input 1")
    plt.ylabel("Input 2")
    plt.legend()
    plt.show()

print("Calling NAND decision boundary.")
nand_decision_boundary()
print("NAND decision boundary end.")

"""- The decision boundary for the NAND gate is a straight line because a perceptron uses a linear equation to separate inputs into two classes. This is why the regions (brown and blue) are divided by a linear boundary."""

# NOR
# Visualize the NOR Decision Boundary
print("NOR Gate Decision Boundary")

def nor_decision_boundary():
    # Define inputs and their corresponding NOR outputs
    input_combinations = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
    nor_outputs = np.array([nor_gate(inputs[0], inputs[1]) for inputs in input_combinations])

    # Generate a grid of points for decision boundary visualization
    x_range = np.linspace(-0.5, 1.5, 100)
    y_range = np.linspace(-0.5, 1.5, 100)
    x_grid, y_grid = np.meshgrid(x_range, y_range)

    # Evaluate the NOR gate for each point in the grid
    grid_points = np.c_[x_grid.ravel(), y_grid.ravel()]
    boundary_values = np.array([nor_gate(point[0], point[1]) for point in grid_points])
    boundary_values = boundary_values.reshape(x_grid.shape)

    # Plot the decision boundary
    decision_display = DecisionBoundaryDisplay(xx0=x_grid, xx1=y_grid, response=boundary_values)
    decision_display.plot(cmap=plt.cm.Paired, alpha=0.5)

    # Overlay input points with their corresponding outputs
    plt.scatter(
        input_combinations[:, 0],
        input_combinations[:, 1],
        c=nor_outputs,
        edgecolor="black",
        cmap=plt.cm.Paired,
        label="Input Points"
    )

    # Add title, labels, and legend
    plt.title("NOR Gate: Decision Boundary")
    plt.xlabel("Input 1")
    plt.ylabel("Input 2")
    plt.legend()
    plt.show()

print("Calling NOR decision boundary.")
nor_decision_boundary()

"""- The decision boundary for the NOR gate is also a straight line because the perceptron separates the input space into two linear regions. Here, the brown region corresponds to output 0, and the blue region corresponds to output 1, divided by a linear boundary."""

#XOR Decision Boundary
print("XOR Gate Decision Boundary")

def xor_decision_boundary():
    # Define input combinations and their corresponding XOR outputs
    input_combinations = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
    xor_outputs = np.array([xor_gate(inputs[0], inputs[1]) for inputs in input_combinations])

    # Generate a grid of points for decision boundary visualization
    x_range = np.linspace(-0.5, 1.5, 100)  # X-axis range
    y_range = np.linspace(-0.5, 1.5, 100)  # Y-axis range
    x_grid, y_grid = np.meshgrid(x_range, y_range)

    # Evaluate the XOR gate for each point in the grid
    grid_points = np.c_[x_grid.ravel(), y_grid.ravel()]
    boundary_values = np.array([xor_gate(point[0], point[1]) for point in grid_points])
    boundary_values = boundary_values.reshape(x_grid.shape)

    # Plot the decision boundary
    decision_display = DecisionBoundaryDisplay(xx0=x_grid, xx1=y_grid, response=boundary_values)
    decision_display.plot(cmap=plt.cm.Paired, alpha=0.5)

    # Overlay input points with their corresponding outputs
    plt.scatter(
        input_combinations[:, 0],
        input_combinations[:, 1],
        c=xor_outputs,
        edgecolor="black",
        cmap=plt.cm.Paired,
        label="Input Points"
    )

    # Add title, labels, and legend
    plt.title("XOR Gate: Decision Boundary")
    plt.xlabel("Input 1")
    plt.ylabel("Input 2")
    plt.legend()
    plt.show()

print("Calling XOR decision boundary.")
xor_decision_boundary()

"""- The XOR gate decision boundary is non-linear, as a single-layer perceptron cannot solve the XOR problem. The plot shows two separate brown regions (output 0) divided by blue regions (output 1), indicating the need for multiple linear boundaries or a more complex model (like a multi-layer perceptron) to capture the XOR logic.

## Question 5 [5 marks]
"""

# Generalized XOR for n inputs
def generalized_XOR(inputs):
    output = inputs[0]
    for i in range(1, len(inputs)):
        output = xor_gate(output, inputs[i])
    return output

print("Test cases for n=3")
def test_generalized_XOR_3():
    # Test for n=3 inputs
    inputs_n3 = np.array([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1],
                          [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]])
    outputs_n3 = np.array([generalized_XOR(x) for x in inputs_n3])
    print("XOR for n=3 inputs:")
    for inp, out in zip(inputs_n3, outputs_n3):
        print(f"Inputs: {inp}, XOR Output: {out}")

print("Calling test_generalized_XOR_3.")
test_generalized_XOR_3()

print("Test cases for n=4")
def test_generalized_XOR_4():

    # Test for n=4 inputs
    inputs_n4 = np.array([[0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 0, 1, 1],
                          [0, 1, 0, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 1, 1, 1],
                          [1, 0, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 0, 1, 1],
                          [1, 1, 0, 0], [1, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1]])
    outputs_n4 = np.array([generalized_XOR(x) for x in inputs_n4])
    print("\nXOR for n=4 inputs:")
    for inp, out in zip(inputs_n4, outputs_n4):
        print(f"Inputs: {inp}, XOR Output: {out}")

print("Calling test_generalized_XOR_4.")
test_generalized_XOR_4()

